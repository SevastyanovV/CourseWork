Работа написана на Windows, поэтому нужно подправить clear в Makefile.

В файле Main.c содержится 3 функции, осуществляющие взаимодействие с сортировка-
ми. Ниже представлено их описание, все они рассчитаны на тип данных int. Выбор
функции осуществляется её раскомментированием в теле main().

Первая из них - test(), она не принимает никаких аргументов, а самостоятельно
считывает один набор данных с файла input.txt, имеющий следующий формат: коли-
чество чисел и сами числа. В консоль выводится сначала исходный и отсортирован-
ный массивы, затем, если всё отсортировано верно, то об этом просто сообщается,
в противном случае выводятся индексы ошибок, сообщается о некорректности, а так-
же выводятся количество ошибок и правильный вариант отсортированного массива. К
сожалению, чтобы выбрать сортировку для запуска, придётся самостоятельно указать
нужную в функции (с остальными двумя функциями ситуация та же). Для хоть какого-
то удобства функцию сортировки можно скопировать из функции tests(), речь о ко-
торой пойдёт далее, причём все имена передаваемых параметров в этих функциях
совпадают.

Вторая функция - tests(). Принимает два параметра: первый - количество элементов
в массиве, который она самостоятельно заполняет случайными числами (однако числа
будут одинаковыми для разных запусков ввиду отсутствия srand()), второй аргумент
- тип проверки массива: если передать число 0 - элементы отсортированного масси-
ва будут просто проверяться на неубывание (быстрее), если передать любое другое
число, то будет создана и отсортирована библиотечной сортировкой копия массива,
с которой будет происходить поэлементное сравнение результата работы тестируемой
сортировки (медленнее), к слову, это же происходило и в функции test(). Генера-
ция массивов происходит в цикле, при каждом успешном выполнении на новой строчке
выводится "correctly" (она будет выводиться крайне часто при работе с короткими
массивами, поэтому стоит её ЗАКОММЕНТИРОВАТЬ (строка 83)). В случае некорректно-
го выполнения сортировки будут выведены: индексы ошибок и их количество, индексы
элементов массива, под ними сами элементы исходного, неправильно и правильно от-
сортированных массивов.

Третья функция - benchmark(). Принимает 6 аргументов:
1. указатель на первый элемент массива (подразумевается, что его размера хватит
для корректного выполнения),
2. название папки, откуда необходимо брать файлы, с приписанным справа символом
"/" (эта функция требует для работы заранее сгенерированных файлов, этим занима-
ется программа Input_maker.c, о ней будет ниже). Подразумевается, что папки мо-
гут иметь только 2 названия: inp16 и inp32 (об этом тоже ниже),
3. сколько различных размерностей массивов нужно обработать,
4. сколько файлов каждой размерности (подразумевается, что для каждой размернос-
ти количество файлов одинаково),
5. массив размерностей (в нём должно быть элементов столько, сколько передано
3-им аргументом),
6. 0 - если нужно выводить результат в файл, помещаемый в папке outp, с таким же
названием, как и файл, из которого происходит считывание (файла будет создан в
случае отсутствия), другое число - если вывод в файл не нужен.
Эта функция сортирует массивы, считываемые из файлов, а также для каждой размер-
ности создаёт и тестирует сортировку на массивах, отсортированных в порядке воз-
растания и убывания (в двух этих местах - строки 215 и 226) тоже нужно менять
сортировку руками.
В результате мы получаем набор строк следующего формата: список ошибок на от-
дельной строке, если они есть, далее количество элементов, номер обрабатываемого
файла (начиная с 1) внутри рассматриваемой размерности, время выполнения в ms,
в случае некорректной сортировки - количество ошибок и фразу "not correct", либо
же, в случае успеха - слово "correct". Для последних двух массивов вместо номера
файла выводится "forward order" или "reverse order".

ВНИМАНИЕ: в случае большого количества ошибок терминалу будет больно, вывод ин-
дексов можно отключить в строках 16 и 30!

Перед запуском Input_maker.c создать три папки: "inp16", "inp32", "outp".
Программа Input_maker.c: перед main() в define нужно выбрать имя папки: inp16/
или inp32/ (строка 6), в зависимости от этого будут генерироваться либо двух-
байтные, либо четырёхбайтные числа. Далее необходимо в константах
numOfDimensions и numOfDuplicates (строка 10) указать количество размерностей и
количество файлов каждой размерности и в строке 14 в массиве dim указать эти
размерности. После этого запустить.
Всё уже настроено заранее.

В файле Less_effective.h хранятся менее эффективные реализации некоторых сорти-
ровок.

Вопросы:

1. Копирование в несуществующий элемент (следующая ячейка памяти после последне-
го элемента) нуля (0) байт с помощью memcpy (сортировки вставками с бинарным
поиском) является ли ошибкой и необходимо ли добавить проверку или нет (в файле
support_sorts.c строки 51-53, 70-72, 156-157)?

2. Нужно ли переписывать на указатели парные сортировки вставками?

3. Нужно ли добавлять модификатор INLINE (см. defines.h) сортировкам вставками и
использовать в них register?
